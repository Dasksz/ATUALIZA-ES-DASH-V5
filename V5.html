<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Uploader de Dados do Dashboard (V5 Corrigido)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 1. ADICIONADO: Biblioteca do Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f6; }
        .file-input-label { display: block; text-align: left; font-size: 0.875rem; font-weight: 500; color: #475569; margin-bottom: 0.5rem; }
        .progress-bar-container { background-color: #e2e8f0; border-radius: 0.5rem; overflow: hidden; }
        .progress-bar { background-color: #0d9488; height: 100%; transition: width 0.3s ease-in-out; }
    </style>
</head>
<body class="text-slate-800 flex items-center justify-center min-h-screen">
    <div class="text-center p-8 bg-white rounded-lg shadow-2xl max-w-lg w-full m-4 border border-slate-200">
        <h1 class="text-2xl font-bold text-slate-900 mb-4">Uploader (Admin) - V5 Corrigido</h1>
        <p class="text-slate-600 mb-6">Carregue os arquivos para enviar os dados ao Supabase. Esta p√°gina deve ser mantida em segredo.</p>

        <!-- 2. ADICIONADO: Campos de configura√ß√£o do Supabase -->
        <div class="space-y-4 mb-6 text-left">
            <div>
                <label for="supabase-url" class="file-input-label">URL do Projeto Supabase</label>
                <input type="text" id="supabase-url" placeholder="https://[seu-id].supabase.co" class="w-full text-sm text-slate-700 p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500" value="https://dhozwhfmrwiumwpcqabi.supabase.co">
            </div>
            <div>
                <label for="supabase-key" class="file-input-label">Chave Secreta (service_role) ü§´</label>
                <input type="password" id="supabase-key" placeholder="Cole sua chave secreta aqui..." class="w-full text-sm text-slate-700 p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500">
                <p class="text-xs text-slate-500 mt-1">Esta chave NUNCA √© salva. Voc√™ deve digit√°-la toda vez que for usar.</p>
            </div>
        </div>

        <div class="space-y-4 mb-6 border-t border-slate-200 pt-6">
            <div>
                <label for="sales-file-input" class="file-input-label">1. Arquivo de Vendas (M√™s Atual)</label>
                <input type="file" id="sales-file-input" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-200 file:text-slate-700 hover:file:bg-slate-300" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="clients-file-input" class="file-input-label">2. Cadastro de Clientes</label>
                <input type="file" id="clients-file-input" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-200 file:text-slate-700 hover:file:bg-slate-300" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="products-file-input" class="file-input-label">3. Cadastro de Produtos</label>
                <input type="file" id="products-file-input" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-200 file:text-slate-700 hover:file:bg-slate-300" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="history-file-input" class="file-input-label">4. Hist√≥rico de Vendas (Trimestre Anterior)</label>
                <input type="file" id="history-file-input" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-200 file:text-slate-700 hover:file:bg-slate-300" accept=".csv, .xls, .xlsx"/>
            </div>
             <div>
                <label for="innovations-file-input" class="file-input-label">5. Planilha de Inova√ß√µes (M√™s)</label>
                <input type="file" id="innovations-file-input" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-200 file:text-slate-700 hover:file:bg-slate-300" accept=".csv, .xls, .xlsx"/>
            </div>
        </div>

        <!-- 3. MODIFICADO: O bot√£o agora envia para o Supabase -->
        <button id="generate-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg w-full disabled:bg-slate-300" disabled>
            Enviar Dados para o Supabase
        </button>

        <div id="status-container" class="hidden mt-6 text-sm h-12 flex flex-col justify-center">
            <p id="status-text" class="mb-2"></p>
            <div class="progress-bar-container w-full h-2">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
        </div>
    </div>

    <!-- 
      4. INSERIDO: O "c√©rebro" da sua ferramenta (Web Worker).
      (Sem altera√ß√µes no worker)
    -->
    <script id="worker-script" type="text/worker-javascript">
        self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');

        function parseDate(dateString) {
            if (!dateString) return null;
            if (dateString instanceof Date) {
                return !isNaN(dateString.getTime()) ? dateString : null;
            }
            if (typeof dateString === 'number') {
                return new Date(Math.round((dateString - 25569) * 86400 * 1000));
            }
            if (typeof dateString !== 'string') return null;

            if (dateString.length === 10 && dateString.charAt(2) === '/' && dateString.charAt(5) === '/') {
                const [day, month, year] = dateString.split('/');
                if (year.length === 4) {
                    return new Date(`${year}-${month}-${day}T00:00:00`);
                }
            }
            
            const isoDate = new Date(dateString);
            return !isNaN(isoDate.getTime()) ? isoDate : null;
        }

        function parseBrazilianNumber(value) {
            if (typeof value === 'number') return value;
            if (typeof value !== 'string' || !value) return 0;
            
            let numberString = value.replace(/R\$\s?/g, '').trim();
            
            const lastComma = numberString.lastIndexOf(',');
            const lastDot = numberString.lastIndexOf('.');

            if (lastComma > lastDot) {
                numberString = numberString.replace(/\./g, '').replace(',', '.');
            } else {
                numberString = numberString.replace(/,/g, '');
            }
            
            const number = parseFloat(numberString);
            return isNaN(number) ? 0 : number;
        }

        const readFile = (file) => {
            return new Promise((resolve, reject) => {
                if (!file) {
                    resolve([]);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let jsonData;
                        const data = event.target.result;
                        if (file.name.endsWith('.csv')) {
                            let decodedData;
                            try {
                                decodedData = new TextDecoder('utf-8', { fatal: true }).decode(new Uint8Array(data));
                            } catch (e) {
                                decodedData = new TextDecoder('iso-8859-1').decode(new Uint8Array(data));
                            }

                            const lines = decodedData.split(/\r?\n/).filter(line => line.trim() !== '');
                            if (lines.length < 1) {
                                resolve([]);
                                return;
                            };

                            const firstLine = lines[0];
                            const delimiter = firstLine.includes(';') ? ';' : ',';
                            
                            const headers = lines.shift().trim().split(delimiter).map(h => h.replace(/"/g, '').trim().replace(/^\uFEFF/, ''));
                            
                            jsonData = lines.map(line => {
                                const values = line.split(delimiter);
                                let row = {};
                                for (let i = 0; i < headers.length; i++) {
                                    row[headers[i]] = (values[i] || '').replace(/"/g, '').trim();
                                }
                                return row;
                            });
                        } else {
                            const workbook = XLSX.read(new Uint8Array(data), {type: 'array'});
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, cellDates: true });
                        }
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error(`Erro ao ler o arquivo '${file.name}'.`));
                reader.readAsArrayBuffer(file);
            });
        };

        const processSalesData = (rawData, clientMap, productMasterMap, newRcaSupervisorMap) => {
            return rawData.map(rawRow => {
                // As chaves no rawRow (ex: 'CODCLI') v√™m do cabe√ßalho do Excel/CSV
                const codCliStr = String(rawRow['CODCLI']).trim();
                const clientInfo = clientMap.get(codCliStr) || {};
                
                // L√ìGICA DE ATRIBUI√á√ÉO DE VENDEDOR (inalterada)
                
                // 1. Pega os valores padr√£o da linha de venda
                let vendorName = String(rawRow['NOME'] || '');
                let supervisorName = String(rawRow['SUPERV'] || '');
                let codUsur = String(rawRow['CODUSUR'] || '').trim(); // Este √© o 'codUsurVenda'
                let codSupervisor = String(rawRow['CODSUPERVISOR'] || '').trim();
                const pedido = String(rawRow['PEDIDO'] || '');
                let isAmericanas = false;

                // 2. Regra de Prioridade 1: AMERICANAS S.A 
                const nomeClienteParaLogica = (clientInfo.razaoSocial || clientInfo.fantasia || clientInfo.nomeCliente || '').toUpperCase();
                if (nomeClienteParaLogica.includes('AMERICANAS S.A')) {
                    vendorName = 'AMERICANAS';
                    codUsur = '1001';
                    supervisorName = 'BALCAO';
                    codSupervisor = '';
                    isAmericanas = true;
        
                    if (clientInfo.rcas) { 
                         clientInfo.rca1 = '1001';
                         if (!clientInfo.rcas.includes('1001')) {
                            clientInfo.rcas.unshift('1001');
                         }
                    }
                }

                // 3. Regra de Prioridade 2: Se N√ÉO for Americanas, usa a nova l√≥gica
                if (!isAmericanas) {
                    const rca1Cliente = (clientInfo.rca1 || '').trim();
                    const codUsurVenda = codUsur; // Guarda o CODUSUR original da linha de venda
                    
                    // Prioriza o RCA 1 do cadastro de clientes. Se n√£o tiver, usa o RCA da linha de venda.
                    const codUsurParaBusca = rca1Cliente || codUsurVenda;

                    const rcaInfo = newRcaSupervisorMap.get(codUsurParaBusca);

                    if (rcaInfo) {
                        // Encontrou informa√ß√µes no mapa mestre (usando RCA1 do cliente ou RCA da venda)
                        vendorName = rcaInfo.NOME;
                        supervisorName = rcaInfo.SUPERV;
                        codSupervisor = rcaInfo.CODSUPERVISOR;
                        codUsur = codUsurParaBusca; // Define o CODUSUR final
                    } 
                    else if (rca1Cliente && rca1Cliente !== codUsurVenda) {
                        // Usou o RCA1 do cliente, n√£o achou. Tenta um fallback com o RCA da linha de venda.
                        const fallbackInfo = newRcaSupervisorMap.get(codUsurVenda);
                        if (fallbackInfo) {
                            vendorName = fallbackInfo.NOME;
                            supervisorName = fallbackInfo.SUPERV;
                            codSupervisor = fallbackInfo.CODSUPERVISOR;
                            codUsur = codUsurVenda; // Define o CODUSUR final como o da venda (fallback)
                        } else {
                            // N√£o achou em lugar nenhum, mant√©m os dados da linha (j√° definidos no passo 1)
                            codUsur = codUsurVenda;
                        }
                    } 
                    else {
                        // Se rca1Cliente estava vazio, codUsurParaBusca == codUsurVenda.
                        // Se n√£o achou rcaInfo, significa que o codUsurVenda n√£o est√° no mapa.
                        // Mant√©m os dados da linha (j√° definidos no passo 1) e o codUsur da venda.
                        codUsur = codUsurVenda;
                    }
                }
                // FIM DA L√ìGICA DE ATRIBUI√á√ÉO DE VENDEDOR

                const supervisorUpper = (supervisorName || '').trim().toUpperCase();
                if (supervisorUpper === 'BALCAO' || supervisorUpper === 'BALC√ÉO') supervisorName = 'BALCAO';

                let dtPed = rawRow['DTPED'];
                const dtSaida = rawRow['DTSAIDA'];
                const parsedDtPed = parseDate(dtPed);
                const parsedDtSaida = parseDate(dtSaida);
                if (parsedDtPed && parsedDtSaida && (parsedDtPed.getFullYear() < parsedDtSaida.getFullYear() || (parsedDtPed.getFullYear() === parsedDtSaida.getFullYear() && parsedDtPed.getMonth() < parsedDtSaida.getMonth()))) {
                    dtPed = dtSaida;
                }
                const productCode = String(rawRow['PRODUTO'] || '').trim();
                const qtdeMaster = productMasterMap.get(productCode) || 1;
                const qtVenda = parseInt(String(rawRow['QTVENDA'] || '0').trim(), 10) || 0;

                // REGRA TIPOVENDA (inalterada)
                const tipoVenda = String(rawRow['TIPOVENDA'] || 'N/A').trim();
                const isFaturamento = (tipoVenda === '1' || tipoVenda === '9');
                const vlVendaOriginal = parseBrazilianNumber(rawRow['VLVENDA']);
                const vlBonificOriginal = parseBrazilianNumber(rawRow['VLBONIFIC']);
                const pesoOriginal = parseBrazilianNumber(rawRow['TOTPESOLIQ']);

                let filialValue = String(rawRow['FILIAL'] || '').trim();
                if (filialValue === '5') filialValue = '05';
                if (filialValue === '8') filialValue = '08';

                // CORRE√á√ÉO CR√çTICA: Mapeia todas as chaves para MIN√öSCULAS 
                // para corresponder ao esquema do PostgreSQL (que as converte automaticamente)
                return {
                    pedido: pedido,
                    nome: vendorName,
                    superv: supervisorName,
                    produto: productCode,
                    descricao: String(rawRow['DESCRICAO'] || ''),
                    fornecedor: String(rawRow['FORNECEDOR'] || ''),
                    observacaofor: String(rawRow['OBSERVACAOFOR'] || '').trim(),
                    codfor: String(rawRow['CODFOR'] || '').trim(),
                    codusur: codUsur,
                    codcli: codCliStr,
                    cliente_nome: clientInfo.nomeCliente || 'N/A',
                    cidade: clientInfo.cidade || 'N/A',
                    bairro: clientInfo.bairro || 'N/A',
                    qtvenda: qtVenda,
                    
                    // Valores ajustados e em min√∫sculas
                    vlvenda: isFaturamento ? vlVendaOriginal : 0,
                    vlbonific: isFaturamento ? vlBonificOriginal : (vlVendaOriginal + vlBonificOriginal),
                    totpesoliq: pesoOriginal, 
                    dtped: dtPed,
                    dtsaida: dtSaida,
                    posicao: String(rawRow['POSICAO'] || ''),
                    estoqueunit: parseBrazilianNumber(rawRow['ESTOQUEUNIT']),
                    qtvenda_embalagem_master: isNaN(qtdeMaster) || qtdeMaster === 0 ? 0 : qtVenda / qtdeMaster,
                    tipovenda: tipoVenda,
                    filial: filialValue,
                    // Passa o CODSUPERVISOR para a regra do Tiago
                    codsupervisor: codSupervisor
                };
            });
        };

        function getPassedWorkingDaysInSpecificMonth(year, month, today) {
            let count = 0;
            const date = new Date(year, month, 1);
            while (date <= today && date.getMonth() === month) {
                const dayOfWeek = date.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    count++;
                }
                date.setDate(date.getDate() + 1);
            }
            return count > 0 ? count : 1;
        }


        self.onmessage = async (event) => {
            const { salesFile, clientsFile, productsFile, historyFile, innovationsFile } = event.data;

            try {
                self.postMessage({ type: 'progress', status: 'Lendo arquivos...', percentage: 10 });
                const [salesDataRaw, clientsDataRaw, productsDataRaw, historyDataRaw, innovationsDataRaw] = await Promise.all([
                    readFile(salesFile),
                    readFile(clientsFile),
                    readFile(productsFile),
                    readFile(historyFile),
                    readFile(innovationsFile)
                ]);

                self.postMessage({ type: 'progress', status: 'Criando mapa mestre de supervisores...', percentage: 20 });
                const newRcaSupervisorMap = new Map();
                const lastSaleDateMap = new Map();

                // Usa vendas atuais E hist√≥ricas para o mapa mestre (inalterado)
                const allSalesForMap = [...salesDataRaw, ...historyDataRaw];

                allSalesForMap.forEach(row => {
                    try {
                        const codUsur = String(row['CODUSUR'] || '').trim();
                        if (codUsur === '1001') return;

                        const dtPed = row['DTPED'];
                        if (!codUsur || !dtPed) return;

                        const saleDate = parseDate(dtPed);
                        if (!saleDate || isNaN(saleDate.getTime())) return;

                        const lastDate = lastSaleDateMap.get(codUsur);
                        if (!lastDate || saleDate >= lastDate) {
                            lastSaleDateMap.set(codUsur, saleDate);
                            newRcaSupervisorMap.set(codUsur, {
                                NOME: String(row['NOME'] || ''),
                                SUPERV: String(row['SUPERV'] || ''),
                                CODSUPERVISOR: String(row['CODSUPERVISOR'] || '').trim()
                            });
                        }
                    } catch (e) {
                        console.error('Erro ao processar linha para mapa mestre:', e, row);
                    }
                });

                self.postMessage({ type: 'progress', status: 'Extraindo estoque do arquivo de vendas...', percentage: 25 });
                const stockMap05 = new Map();
                const stockMap08 = new Map();

                salesDataRaw.forEach(item => {
                    const productCode = String(item['PRODUTO'] || '').trim();
                    let branch = String(item['FILIAL'] || '').trim();
                    const stockQtyCx = parseBrazilianNumber(item['ESTOQUECX']);

                    if (productCode && branch) {
                        if (branch === '5') branch = '05';
                        if (branch === '8') branch = '08';

                        if (branch === '05') {
                            stockMap05.set(productCode, stockQtyCx);
                        } else if (branch === '08') {
                            stockMap08.set(productCode, stockQtyCx);
                        }
                    }
                });

                self.postMessage({ type: 'progress', status: 'Mapeando produtos e criando lista de ativos...', percentage: 30 });
                const productMasterMap = new Map();
                const activeProductCodesFromCadastro = new Set();
                const productDetailsMap = new Map();

                productsDataRaw.forEach(prod => {
                    const productCode = String(prod['C√≥digo'] || '').trim();
                    if (!productCode) return;
                    activeProductCodesFromCadastro.add(productCode);
                    let qtdeMaster = parseInt(prod['Qtde embalagem master(Compra)'], 10);
                    if (isNaN(qtdeMaster) || qtdeMaster <= 0) qtdeMaster = 1;
                    productMasterMap.set(productCode, qtdeMaster);
                    if (!productDetailsMap.has(productCode)) {
                        productDetailsMap.set(productCode, {
                            descricao: String(prod['Descri√ß√£o'] || `Produto ${productCode}`),
                            fornecedor: String(prod['Nome do fornecedor'] || 'N/A'),
                            codfor: String(prod['Fornecedor'] || 'N/A'),
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† dtCadastro: prod['Dt.Cadastro'] || null
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });


                const clientRcaOverrides = new Map();
                salesDataRaw.forEach(rawRow => {
                    const pedido = String(rawRow['PEDIDO'] || '');
                    const codCli = String(rawRow['CODCLI'] || '').trim();
                    if(!codCli) return;
                });

                self.postMessage({ type: 'progress', status: 'Processando clientes...', percentage: 50 });
                const clientMap = new Map();
                clientsDataRaw.forEach(client => {
                    const codCli = String(client['C√≥digo'] || '').trim();
                    if (!codCli) return;

                    const rca1 = String(client['RCA 1'] || '');
                    const rca2 = String(client['RCA 2'] || '');
                    const rcas = new Set();
                    if (rca1) rcas.add(rca1);
                    if (rca2) rcas.add(rca2);

                    let registrationDateStr = client['Data e Hora de Cadastro'] || '';
                    if (registrationDateStr.includes(' ')) registrationDateStr = registrationDateStr.split(' ')[0];

                    const clientData = {
                        'C√≥digo': codCli,
                        rcas: Array.from(rcas),
                        rca1: rca1,
                        rca2: rca2,
                        cidade: String(client['Nome da Cidade'] || 'N/A'),
                        nomeCliente: String(client['Fantasia'] || client['Cliente'] || 'N/A'),
                        bairro: String(client['Bairro'] || 'N/A'),
                        razaoSocial: String(client['Cliente'] || 'N/A'),
                        fantasia: String(client['Fantasia'] || 'N/A'),
                        cnpj_cpf: String(client['CNPJ/CPF'] || 'N/A'),
                        endereco: String(client['Endere√ßo Comercial'] || client['Endere√ßo'] || 'N/A'),
                        numero: String(client['N√∫mero'] || 'SN'),
                        cep: String(client['CEP'] || 'N/A'),
                        telefone: String(client['Telefone Comercial'] || 'N/A'),
                        email: String(client['E-mail'] || 'N/A'),
                        ramo: String(client['Descricao'] || 'N/A'),
                        ultimaCompra: client['Data da √öltima Compra'],
                        dataCadastro: registrationDateStr,
                        bloqueio: String(client['Bloqueio'] || '').trim().toUpperCase(),
                        inscricaoEstadual: String(client['Insc. Est. / Produtor'] || 'N/A')
                    };
                    if (clientRcaOverrides.has(codCli)) clientData.rcas.unshift(clientRcaOverrides.get(codCli));
                    clientMap.set(codCli, clientData);
                });

                self.postMessage({ type: 'progress', status: 'Cruzando dados de vendas...', percentage: 70 });
                const processedSalesData = processSalesData(salesDataRaw, clientMap, productMasterMap, newRcaSupervisorMap);
                const processedHistoryData = processSalesData(historyDataRaw, clientMap, productMasterMap, newRcaSupervisorMap);

                self.postMessage({ type: 'progress', status: 'Aplicando regra de filial...', percentage: 75 });

                // L√≥gica de Override de Filial (inalterada)
                const allProcessedSales = [...processedSalesData, ...processedHistoryData].sort((a, b) => {
                    const dateA = parseDate(a.dtped) || new Date(0); // ATUALIZADO: Usando dtped
                    const dateB = parseDate(b.dtped) || new Date(0); // ATUALIZADO: Usando dtped
                    return dateA - dateB;
                });

                const clientLastBranch = new Map();
                const clientsWith05Purchase = new Set();

                allProcessedSales.forEach(sale => {
                    const codCli = sale.codcli; // ATUALIZADO: Usando codcli
                    const filial = sale.filial; // ATUALIZADO: Usando filial
                    if (codCli && filial) {
                        clientLastBranch.set(codCli, filial);
                        if (filial === '05') {
                            clientsWith05Purchase.add(codCli);
                        }
                    }
                });

                const clientBranchOverride = new Map();
                clientsWith05Purchase.forEach(codCli => {
                    const lastBranch = clientLastBranch.get(codCli);
                    if (lastBranch && lastBranch === '08') {
                        clientBranchOverride.set(codCli, '08');
                    }
                });

                const applyBranchOverride = (salesArray, overrideMap) => {
                    return salesArray.map(sale => {
                        const override = overrideMap.get(sale.codcli); // ATUALIZADO: Usando codcli
                        if (override && sale.filial === '05') { // ATUALIZADO: Usando filial
                            return { ...sale, filial: override };
                        }
                        return sale;
                    });
                };

                let finalSalesData = applyBranchOverride(processedSalesData, clientBranchOverride);
                let finalHistoryData = applyBranchOverride(processedHistoryData, clientBranchOverride);

                self.postMessage({ type: 'progress', status: 'Aplicando regra espec√≠fica para Supervisor Tiago...', percentage: 78 });
                const tiagoSellersToMoveTo08 = new Set(['291', '292', '293', '284', '289', '287', '286']);

                const applyTiagoRule = (salesArray) => {
                    return salesArray.map(sale => {
                        // Assume que CODSUPERVISOR e CODUSUR v√™m com as chaves do rawRow
                        if (sale.codsupervisor === '12' && tiagoSellersToMoveTo08.has(sale.codusur)) {
                             // ATUALIZADO: Usa codsupervisor e codusur, e altera filial
                            return { ...sale, filial: '08' }; 
                        }
                        return sale;
                    });
                };

                finalSalesData = applyTiagoRule(finalSalesData);
                finalHistoryData = applyTiagoRule(finalHistoryData);


                self.postMessage({ type: 'progress', status: 'Atualizando datas de compra...', percentage: 80 });
                const latestSaleDateByClient = new Map();
                finalSalesData.forEach(sale => {
                    const codcli = sale.codcli; // ATUALIZADO: Usando codcli
                    const saleDate = parseDate(sale.dtped); // ATUALIZADO: Usando dtped
                    if (codcli && saleDate) {
                        const existingDate = latestSaleDateByClient.get(codcli);
                        if (!existingDate || saleDate > existingDate) latestSaleDateByClient.set(codcli, saleDate);
                    }
                });
                clientMap.forEach((client, codcli) => {
                    const lastPurchaseDate = parseDate(client.ultimaCompra);
                    const latestSaleDate = latestSaleDateByClient.get(codcli);
                    if (latestSaleDate && (!lastPurchaseDate || isNaN(lastPurchaseDate.getTime()) || latestSaleDate > lastPurchaseDate)) {
                        client.ultimaCompra = latestSaleDate;
                    }
                });

                self.postMessage({ type: 'progress', status: 'Agregando pedidos...', percentage: 90 });
                const aggregateOrders = (data) => {
                    const orders = new Map();
                    data.forEach(row => {
                        if (!row.pedido) return; // CORRIGIDO: row.PEDIDO -> row.pedido
                        if (!orders.has(row.pedido)) { // CORRIGIDO: row.PEDIDO -> row.pedido
                            orders.set(row.pedido, { // CORRIGIDO: row.PEDIDO -> row.pedido
                                ...row,
                                // CORRIGIDO: Todas as chaves em min√∫sculas
                                qtvenda: 0,
                                vlvenda: 0,
                                vlbonific: 0,
                                totpesoliq: 0,
                                fornecedores: new Set(),
                                codfors: new Set()
                            });
                        }
                        const order = orders.get(row.pedido); // CORRIGIDO: row.PEDIDO -> row.pedido
                        // CORRIGIDO: Todas as chaves em min√∫sculas
                        order.qtvenda += row.qtvenda;
                        order.vlvenda += row.vlvenda;
                        order.vlbonific += row.vlbonific;
                        order.totpesoliq += row.totpesoliq;
                        if (row.observacaofor) order.fornecedores.add(row.observacaofor); // CORRIGIDO: row.OBSERVACAOFOR -> row.observacaofor
                        if (row.codfor) order.codfors.add(row.codfor); // CORRIGIDO: row.CODFOR -> row.codfor
                    });
                    return Array.from(orders.values()).map(order => {
                        // CORRIGIDO: Todas as chaves em min√∫sculas
                        order.fornecedores_list = Array.from(order.fornecedores);
                        order.fornecedores_str = order.fornecedores_list.join(', ');
                        order.codfors_list = Array.from(order.codfors);
                        return order;
                    });
                };
                const aggregatedByOrder = aggregateOrders(finalSalesData);

                const lastSaleDate = finalSalesData.length > 0
                    ? new Date(Math.max.apply(null, finalSalesData.map(s => parseDate(s.dtped)).filter(d => d && !isNaN(d)))) // CORRIGIDO: s.DTPED -> s.dtped
                    : new Date();
                lastSaleDate.setHours(0,0,0,0);
                const passedWorkingDaysCurrentMonth = getPassedWorkingDaysInSpecificMonth(
                    lastSaleDate.getFullYear(),
                    lastSaleDate.getMonth(),
                    lastSaleDate
                );


                self.postMessage({ type: 'progress', status: 'Finalizando...', percentage: 100 });

                self.postMessage({
                    type: 'result',
                    data: {
                        detailed: finalSalesData,
                        history: finalHistoryData,
                        byOrder: aggregatedByOrder,
                        clients: Array.from(clientMap.values()),
                        stockMap05: Object.fromEntries(stockMap05),
                        stockMap08: Object.fromEntries(stockMap08),
                        innovationsMonth: innovationsDataRaw,
                        activeProductCodes: Array.from(activeProductCodesFromCadastro),
                        productDetails: Object.fromEntries(productDetailsMap),
                        passedWorkingDaysCurrentMonth: passedWorkingDaysCurrentMonth
                    }
                });

            } catch (error) {
                self.postMessage({ type: 'error', message: error.message + (error.stack ? `\nStack: ${error.stack}`: '') });
            }
        };
    </script>
    

    <!-- 
      Este script n√£o √© mais necess√°rio aqui, pois a l√≥gica 
      de gera√ß√£o do relat√≥rio agora est√° no index.html
    -->
    <!-- <script id="report-logic-script" type="text/template"> ... </script> -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const salesFileInput = document.getElementById('sales-file-input');
            const clientsFileInput = document.getElementById('clients-file-input');
            const productsFileInput = document.getElementById('products-file-input');
            const historyFileInput = document.getElementById('history-file-input');
            const innovationsFileInput = document.getElementById('innovations-file-input');
            const generateBtn = document.getElementById('generate-btn');

            const statusContainer = document.getElementById('status-container');
            const statusText = document.getElementById('status-text');
            const progressBar = document.getElementById('progress-bar');
            
            // Campos do Supabase
            const supabaseUrlInput = document.getElementById('supabase-url');
            const supabaseKeyInput = document.getElementById('supabase-key');

            let files = {};

            const checkFiles = () => {
                // MODIFICADO: Habilita o bot√£o se PELO MENOS UM arquivo estiver carregado
                const allFilesLoaded = files.salesFile || files.clientsFile || files.productsFile || files.historyFile || files.innovationsFile;
                const supabaseConfigReady = supabaseUrlInput.value && supabaseKeyInput.value;
                generateBtn.disabled = !(allFilesLoaded && supabaseConfigReady);
            };

            salesFileInput.addEventListener('change', (e) => { files.salesFile = e.target.files[0]; checkFiles(); });
            clientsFileInput.addEventListener('change', (e) => { files.clientsFile = e.target.files[0]; checkFiles(); });
            productsFileInput.addEventListener('change', (e) => { files.productsFile = e.target.files[0]; checkFiles(); });
            historyFileInput.addEventListener('change', (e) => { files.historyFile = e.target.files[0]; checkFiles(); });
            innovationsFileInput.addEventListener('change', (e) => { files.innovationsFile = e.target.files[0]; checkFiles(); });
            supabaseUrlInput.addEventListener('input', checkFiles);
            supabaseKeyInput.addEventListener('input', checkFiles);

            const workerScript = document.getElementById('worker-script').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);
            const worker = new Worker(workerUrl);

            worker.onmessage = (event) => {
                const { type, status, percentage, data, message } = event.data;

                if (type === 'progress') {
                    statusText.textContent = status;
                    progressBar.style.width = `${percentage}%`;
                } else if (type === 'result') {
                    // 4. MODIFICADO: Em vez de gerar um arquivo, envia os dados para o Supabase
                    statusText.textContent = 'Dados processados! Enviando para o Supabase...';
                    progressBar.style.width = '100%';
                    enviarDadosParaSupabase(data);
                } else if (type === 'error') {
                    statusContainer.classList.remove('hidden');
                    statusText.innerHTML = `<p class="text-red-500">Erro no Worker: ${message}</p>`;
                    progressBar.style.width = '0%';
                    generateBtn.disabled = false;
                }
            };

            generateBtn.addEventListener('click', () => {
                if (generateBtn.disabled) return;

                generateBtn.disabled = true;
                statusContainer.classList.remove('hidden');
                statusText.textContent = 'A iniciar o processamento...';
                progressBar.style.width = '0%';

                // MODIFICADO: Envia os arquivos que existem, ou 'null' se n√£o existirem
                worker.postMessage({
                    salesFile: files.salesFile || null,
                    clientsFile: files.clientsFile || null,
                    productsFile: files.productsFile || null,
                    historyFile: files.historyFile || null,
                    innovationsFile: files.innovationsFile || null
                });
            });

            // 5. NOVO: Helper para enviar dados grandes em lotes
            async function enviarDadosEmLotes(supabaseClient, nomeTabela, dados, statusText, progressBar, progressoInicial, progressoFinal) {
                const TAMANHO_LOTE = 500; // Define o tamanho de cada "pacote"
                const totalLotes = Math.ceil(dados.length / TAMANHO_LOTE);

                try {
                    // Limpa a tabela antiga ANTES de inserir novos dados
                    statusText.textContent = `(Etapa ${progressoInicial < 40 ? '1' : '2'}/8) Limpando dados antigos de ${nomeTabela}...`;
                    const { error: deleteError } = await supabaseClient
                        .from(nomeTabela)
                        .delete()
                        .neq('id', -1); // Exclui todas as linhas (onde ID n√£o √© -1, ou seja, todas)
                    
                    if (deleteError) throw new Error(`Falha ao limpar ${nomeTabela}: ${deleteError.message}`);

                    // Insere os novos dados em lotes
                    for (let i = 0; i < totalLotes; i++) {
                        const inicio = i * TAMANHO_LOTE;
                        const fim = inicio + TAMANHO_LOTE;
                        const lote = dados.slice(inicio, fim);

                        // Atualiza o status para o lote atual
                        const statusMsg = `(Etapa ${progressoInicial < 40 ? '1' : '2'}/8) Enviando ${nomeTabela} (Lote ${i + 1}/${totalLotes})...`;
                        statusText.textContent = statusMsg;

                        const { error: insertError } = await supabaseClient
                            .from(nomeTabela)
                            .insert(lote);

                        if (insertError) {
                            console.error(`Erro no lote ${i+1} de ${nomeTabela}:`, insertError);
                            throw new Error(`Erro ao inserir ${nomeTabela} (Lote ${i + 1}): ${insertError.message}`);
                        }

                        // Atualiza a barra de progresso
                        const progressoLote = (i + 1) / totalLotes;
                        const progressoTotal = progressoInicial + (progressoLote * (progressoFinal - progressoInicial));
                        progressBar.style.width = `${progressoTotal}%`;
                    }
                } catch (error) {
                    // Se falhar, re-lan√ßa o erro para ser pego pela fun√ß√£o principal
                    throw error;
                }
            }


            // 6. MODIFICADO: Fun√ß√£o principal de envio atualizada para enviar SELETIVAMENTE
            async function enviarDadosParaSupabase(data) {
                const SUPABASE_URL = supabaseUrlInput.value;
                const SUPABASE_KEY = supabaseKeyInput.value;
                
                if (!SUPABASE_URL || !SUPABASE_KEY) {
                    statusText.innerHTML = `<p class="text-red-500">Erro: URL ou Chave Secreta do Supabase n√£o informada.</p>`;
                    generateBtn.disabled = false;
                    return;
                }

                try {
                    // Inicializa o cliente Supabase com a chave SECRETA
                    const { createClient } = supabase; // Usa a biblioteca global do Supabase
                    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

                    statusText.textContent = 'Conectado! Verificando dados para enviar...';
                    progressBar.style.width = '5%';
                    const now = new Date().toISOString();

                    // --- IN√çCIO DA MODIFICA√á√ÉO: L√≥gica de Envio Seletivo ---

                    // 1. Monta uma lista de tarefas (o que realmente precisamos enviar)
                    const tasks = [];
                    if (data.detailed && data.detailed.length > 0) {
                        tasks.push({ 
                            name: 'Vendas Atuais', 
                            tableName: 'data_detailed', 
                            data: data.detailed, 
                            type: 'lote' 
                        });
                    }
                    if (data.history && data.history.length > 0) {
                        tasks.push({ 
                            name: 'Hist√≥rico', 
                            tableName: 'data_history', 
                            data: data.history, 
                            type: 'lote' 
                        });
                    }
                    if (data.clients && data.clients.length > 0) {
                        tasks.push({ 
                            name: 'Clientes', 
                            tableName: 'data_clients', 
                            data: { id: 1, data: data.clients, updated_at: now }, 
                            type: 'jsonb' 
                        });
                    }
                    if (data.byOrder && data.byOrder.length > 0) {
                        tasks.push({ 
                            name: 'Pedidos', 
                            tableName: 'data_orders', 
                            data: { id: 1, data: data.byOrder, updated_at: now }, 
                            type: 'jsonb' 
                        });
                    }
                    if (data.activeProductCodes && data.activeProductCodes.length > 0) {
                        // O 'productDetails' pode estar vazio, mas 'activeProductCodes' n√£o
                        const productData = {
                            activeProductCodes: data.activeProductCodes,
                            productDetails: data.productDetails
                        };
                        tasks.push({ 
                            name: 'Produtos', 
                            tableName: 'data_products', 
                            data: { id: 1, data: productData, updated_at: now }, 
                            type: 'jsonb' 
                        });
                    }
                    if (data.stockMap05 || data.stockMap08) {
                        // Verifica se os objetos de estoque n√£o est√£o vazios
                        if (Object.keys(data.stockMap05).length > 0 || Object.keys(data.stockMap08).length > 0) {
                             const stockData = {
                                stockMap05: data.stockMap05,
                                stockMap08: data.stockMap08
                            };
                            tasks.push({ 
                                name: 'Estoque', 
                                tableName: 'data_stock', 
                                data: { id: 1, data: stockData, updated_at: now }, 
                                type: 'jsonb' 
                            });
                        }
                    }
                    if (data.innovationsMonth && data.innovationsMonth.length > 0) {
                        tasks.push({ 
                            name: 'Inova√ß√µes', 
                            tableName: 'data_innovations', 
                            data: { id: 1, data: data.innovationsMonth, updated_at: now }, 
                            type: 'jsonb' 
                        });
                    }
                    if (data.passedWorkingDaysCurrentMonth) {
                         const metadata = {
                            passedWorkingDaysCurrentMonth: data.passedWorkingDaysCurrentMonth
                        };
                        tasks.push({ 
                            name: 'Metadados', 
                            tableName: 'data_metadata', 
                            data: { id: 1, data: metadata, updated_at: now }, 
                            type: 'jsonb' 
                        });
                    }

                    // 2. Verifica se h√° algo para fazer
                    if (tasks.length === 0) {
                        statusText.innerHTML = `<p class="text-yellow-500">Nenhum dado novo foi processado. Verifique os arquivos carregados.</p>`;
                        progressBar.style.width = '0%';
                        generateBtn.disabled = false;
                        return;
                    }

                    const totalTasks = tasks.length;
                    
                    // 3. Executa as tarefas em loop
                    for (let i = 0; i < totalTasks; i++) {
                        const task = tasks[i];
                        const taskProgress = ((i + 1) / totalTasks); // Progresso de 0 a 1

                        statusText.textContent = `Enviando (${i + 1}/${totalTasks}): ${task.name}...`;

                        if (task.type === 'lote') {
                            // Envia em lotes (usando o progresso din√¢mico)
                            const progressoInicial = (i / totalTasks) * 100;
                            const progressoFinal = taskProgress * 100;

                            await enviarDadosEmLotes(
                                supabaseClient,
                                task.tableName,
                                task.data,
                                statusText,
                                progressBar,
                                progressoInicial,
                                progressoFinal
                            );
                            
                        } else if (task.type === 'jsonb') {
                            // ######################################################################
                            // ## IN√çCIO DA CORRE√á√ÉO ##
                            // Troca o 'upsert' por 'delete' + 'insert' para garantir a execu√ß√£o,
                            // j√° que 'insert' e 'delete' est√£o a funcionar para as tabelas 'lote'.
                            
                            // 1. Apaga a linha antiga
                            const { error: deleteError } = await supabaseClient
                                .from(task.tableName)
                                .delete()
                                .eq('id', 1); // Apaga especificamente a linha com id 1
                                
                            if (deleteError) throw new Error(`Falha ao limpar ${task.tableName}: ${deleteError.message}`);
                            
                            // 2. Insere a nova linha com os dados
                            // task.data j√° √© { id: 1, data: [...], updated_at: "..." }
                            const { error: insertError } = await supabaseClient
                                .from(task.tableName)
                                .insert(task.data); 

                            if (insertError) throw new Error(`Falha ao inserir ${task.tableName}: ${insertError.message}`);
                            
                            // ## FIM DA CORRE√á√ÉO ##

                            /*
                            // --- C√ìDIGO ANTIGO QUE FALHAVA ---
                            const { error } = await supabaseClient
                                .from(task.tableName)
                                .upsert(task.data);
                            
                            if (error) throw new Error(`${task.tableName}: ${error.message}`);
                            */
                            
                            // Atualiza a barra de progresso de uma vez
                            progressBar.style.width = `${taskProgress * 100}%`;
                        }
                    }

                    // --- FIM DA MODIFICA√á√ÉO ---

                    // SUCESSO!
                    statusText.innerHTML = `<p class="text-green-500">Sucesso! Dados do dashboard atualizados (${totalTasks} tabelas).</p>`;
                    progressBar.style.width = '100%';
                    generateBtn.disabled = false;
                    
                    // Limpa os campos de arquivo para a pr√≥xima
                    salesFileInput.value = '';
                    clientsFileInput.value = '';
                    productsFileInput.value = '';
                    historyFileInput.value = '';
                    innovationsFileInput.value = '';
                    files = {};
                    checkFiles();

                } catch (error) {
                    console.error('Erro no Supabase:', error);
                    // O erro vai aparecer com o nome da tabela, ex: "Erro ao enviar: data_detailed: ..."
                    statusText.innerHTML = `<p class="text-red-500">Erro ao enviar: ${error.message}</p>`;
                    progressBar.style.width = '0%';
                    generateBtn.disabled = false;
                }
            }
        });
    </script>
</body>
</html>
